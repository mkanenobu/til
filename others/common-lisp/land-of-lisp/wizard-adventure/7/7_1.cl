; 7.1 奇妙なリスト

; 3章で学んだ通りLispのリストはコンスセルから作られる、リストの最後のコンスセルの右のスロットはnilになっている
; コンスセルを連ねていくことでどんな長さのリストでも作ることが出来る
(let ((l (cons 1 (cons 2 (cons 3 nil)))))
  (print l)) ; (1 2 3) ; (cons 1 (cons 2 (cons 3 nil))) というデータと (1 2 3) というデータは表面的な見た目が違うだけでデータとしては全く同じ

; ドットリスト
; ではこの「コンスセルの連なり」から外れるとどうなるだろう
; 最後のスロットにnil以外を入れてみる
(let ((l (cons 1 (cons 2 3))))
  (print l)) ; (1 2 . 3)
; 正式なリストの最後にあるべきnilが見つからなかった示すため、Lispは最後の要素の前にドットを入れて表示する
; nil以外の値でリストが終端されているものはドットリストと呼ばれる
; ドットリストを意図的に使うことはあまり無いが、そういったデータ自体は珍しくないので、ドットリストに慣れておく必要はある

; ドット表記は単にconsコマンドのデータモードで使われる別表記であると考えることも出来る
; わざわざ面倒なことをしたければ通常のリストを次のようにドット表記で書くことも出来る
(let ((l '(1 . (2 . (3 . nil)))))
  (print l))

; 対
; Lispプログラムでよく使われる実用的なドットリストは対を簡潔に表現するためのもの
; 例えば数字の2と3の対を表現するとしたら次のようになる
(print (cons 2 3)) ; (2 . 3)
; この形はLispでよく使われる、例えば2次元の座標x, yや複雑なデータの中のキーと値など

; 循環リスト
; 3章で説明したようにコンスセルの連なりで出来たリストはリンクドリストの構造を持っている
; そこでリストの変わったバリアントとして、最後のコンスセルの右のスロットがnilではなく最初のコンスセルを指すようなものを考えてみる
; こういったリストを循環リストという

; Common Lisp環境で循環リストを試すときは次のコマンドを実行しておく必要がある（しないとスタックオーバーフローや無限ループが発生することがある）
; これが有効になっているとデータ表示のためのアルゴリズムが循環リストに対応したものに切り替わる
; このアルゴリズムは遅いのでデフォルトでは無効でオプトインする形になっている
(setf *print-circle* t)

; 循環リストを作る最も簡単な方法はsetfを使って最初の引数の示すところの値を変更してやること
(defparameter foo (list 1 2 3))
; ここで '(1 2 3) としないのはこの後でfooのリストの値を変更するため

; データモードで入力したリスト（リテラルリスト）を変更するのはバッドマナーとされる
; REPLではどちらも変わらないが、ファイルを読み込むような場合にはコンパイラがリテラルリストを定数としてデータ領域に置いておくなどの最適化を行う可能性があるため
; 一旦は「setfで変更するリストはlistコマンドで作る」と覚えておけばよい

; これは単純なリストの最後のnilをリストの先頭を指すように書き換えることで循環リストを作っている
; (cdddr foo) は長さ3（nilを入れると4）の (1 2 3) というリストの最後のnilの場所を指す、そこを自分自身を指すように書き換える
(setf (cdddr foo) foo)
(print foo)

; 連想リスト
; コンスセルから作られるデータ構造の中でも特に便利なのは連想リスト（alist）で、
; alistはキーと値の対になるリスト
; 慣習的にリスト中に同じキーが複数ある場合には最初のものだけを有効とみなすことが多い

; 次の例はBill, Lisa, Johnの3人のコーヒーの注文を表現するalist
(defparameter *drink-order* '((bill . double-espresso)
                              (lisa . small-drip-coffee)
                              (john . medium-latte)))
; 特定の人の注文を得る（キー検索）にはassocを使う
(print (assoc 'lisa *drink-order*))
; assocはリストの最初から順にマッチするキーを探して見つかればキーと値の対を返す

; 例えばここでLisaが「やっぱりもう少しリッチなものを飲もうかしら」と言い出したとしたら、push関数を使って彼女の注文を変更出来る
(push '(lisa . large-mocha-with-whipped-cream) *drink-order*) ; push関数は追加した結果のリストを返す

; push関数は既にあるリストの先頭に要素を追加するだけだが、alistは慣習的に最初に見つかったキーを優先するので、
; Lisaの元の注文（small-drip-coffee）は追加した注文（large-mocha-with-whipped-cream）に上書きされる
(print (assoc 'lisa *drink-order*))

; aliasはとても便利なデータ構造だが、データを取り出すのにあまり効率のいい方法では無いという欠点がある
; そのため、最初に選ばれるデータ構造の一つではあるが、プログラムが成熟するにつれて他のデータ構造に置き換えられることが多い
; （9章でalistをはじめとするリストに基づくデータ構造の性能上の制限についての内容がある）
